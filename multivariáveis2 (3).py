# -*- coding: utf-8 -*-
"""Multivari√°veis2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/168-aG1Y5Fe9pewTfSvwRQl-lkOYQcY5C
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

df_loaded = pd.read_csv('dados_campanha_vest - dados_campanha_vest (1).csv')


import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler # Descomente se voc√™ usou StandardScaler
import joblib # Para salvar/carregar modelos e scalers

# --- Configura√ß√µes Iniciais do Streamlit ---
st.set_page_config(layout="wide", page_title="Simulador de Leads por Investimento")
st.title("üìä Simulador de Leads por Investimento")
st.markdown("Insira o valor do investimento para prever os leads por sexo e tipo de campanha.")

# --- Fun√ß√µes de Cache para Carregamento/Processamento de Dados e Modelo ---
# Para um aplicativo real, voc√™ salvaria e carregaria seu modelo e scalers.
# Para este exemplo, vamos simular o carregamento e o pr√©-processamento inicial.

@st.cache_resource # Usar st.cache_resource para objetos de modelo
def load_model():
    """Carrega o modelo de Regress√£o Linear treinado."""
    try:
        # --- CARREGAMENTO REAL DO MODELO ---
        # Certifique-se de que 'modelo_lr.pkl' est√° no seu reposit√≥rio GitHub.
        modelo = joblib.load('modelo_lr.pkl')
        return modelo
    except FileNotFoundError:
        st.error("Erro: Arquivo 'modelo_lr.pkl' n√£o encontrado. Certifique-se de que o modelo foi salvo no diret√≥rio correto.")
        st.stop() # Para a execu√ß√£o do Streamlit
    except Exception as e:
        st.error(f"Erro ao carregar o modelo: {e}")
        st.stop()
    # --- FIM DA SIMULA√á√ÉO ---

@st.cache_data # Usar st.cache_data para dados e resultados de pr√©-processamento
def load_and_preprocess_data():
    """
    Carrega e pr√©-processa o DataFrame.
    EM UM APP REAL, VOC√ä CARREGARIA SEU DF LIMPO E PR√â-PROCESSADO.
    """
    # Substitua esta parte pelo carregamento do seu DataFrame 'df'
    # Exemplo: df_loaded = pd.read_csv('caminho/para/seu/dados_limpos.csv')
    # Ou, se voc√™ estiver rodando em um ambiente onde 'df' j√° est√° na mem√≥ria:
    # df_loaded = df.copy() # Apenas se 'df' j√° foi carregado e limpo

    # --- SIMULA√á√ÉO: CARREGAMENTO E PR√â-PROCESSAMENTO INICIAL DO DF ---
    # Este bloco √© um placeholder. Voc√™ deve substitu√≠-lo pelo carregamento do seu 'df'
    # e garantir que ele esteja no estado correto (sem NaNs em 'leads', colunas num√©ricas como float).
    try:
        if 'df' in globals():
            st.write("Usando DataFrame 'df' existente na mem√≥ria.")
            df_loaded = globals()['df'].copy()
        else:
            st.error("DataFrame 'df' n√£o encontrado na mem√≥ria. Por favor, certifique-se de que o DataFrame foi carregado e pr√©-processado.")
            st.stop()

        # Recalcular colunas dummies para garantir que X_train_imputed.columns est√° correto
        # Isso √© crucial se o Streamlit rodar de forma independente e n√£o tiver acesso ao df_encoded.
        colunas_categoricas = ['sexo', 'dispositivo', 'idade', 'tipo_de_campanha', 'C√≥digo da moeda']
        df_processed_for_dummies = pd.get_dummies(df_loaded, columns=colunas_categoricas, drop_first=True)

        # Assumindo que X_train_imputed.columns √© uma lista global ou pode ser carregada
        # Voc√™ deve substituir isso pela sua lista real de colunas de X_train_imputed
        # Exemplo: X_train_imputed_columns = joblib.load('caminho/para/suas/colunas_X.pkl')
        if 'X_train_imputed' in globals():
            X_train_imputed_columns = globals()['X_train_imputed'].columns
        else:
            st.error("X_train_imputed n√£o encontrado na mem√≥ria. Por favor, certifique-se de que o X_train_imputed foi criado.")
            st.stop()


        # Calcular KPIs m√©dios por tipo de campanha
        kpi_cols = ['ctr', 'cpl', 'cliques', 'impressoes', 'cpc_medio']
        kpis_medios_por_campanha = df_loaded.groupby('tipo_de_campanha')[kpi_cols].mean().to_dict('index')

        sexo_categorias = sorted(df_loaded['sexo'].dropna().unique())
        tipo_campanha_categorias = sorted(df_loaded['tipo_de_campanha'].dropna().unique())

        # Carregar o scaler se ele foi usado
        scaler = None
        # Exemplo: if 'scaler' in globals(): scaler = globals()['scaler']
        # Ou: scaler = joblib.load('caminho/para/seu/scaler.pkl')

        # Flag para reverter log transform em y
        log_transform_y = False # Mude para True se voc√™ usou np.log1p em y_train

        return df_loaded, df_processed_for_dummies, X_train_imputed_columns, kpis_medios_por_campanha, sexo_categorias, tipo_campanha_categorias, scaler, log_transform_y

    except NameError:
        st.error("Erro ao carregar dados. Verifique se 'df' e 'X_train_imputed' est√£o definidos.")
        st.stop()
    # --- FIM DA SIMULA√á√ÉO ---


# --- Fun√ß√£o de Predi√ß√£o Principal ---
def predict_leads_for_investment(
    novo_investimento_val,
    model,
    X_train_cols,
    kpis_by_campaign,
    sexo_cats,
    campaign_cats,
    df_for_dummies, # DataFrame para garantir que as dummies s√£o criadas corretamente
    scaler_obj=None,
    log_transform_y_flag=False
):
    """
    Gera previs√µes de leads para um novo investimento, discriminado por sexo e tipo de campanha,
    usando KPIs m√©dios espec√≠ficos por tipo de campanha.
    """
    resultados = []
    kpi_cols = ['ctr', 'cpl', 'cliques', 'impressoes', 'cpc_medio']

    for tipo_original in campaign_cats:
        kpis_atuais = kpis_by_campaign.get(tipo_original, {})

        for sexo_original in sexo_cats:
            # Inicializar uma linha de dados para previs√£o com zeros, com base nas colunas do modelo
            data_row = {col: 0 for col in X_train_cols}

            # Preencher com o novo investimento e os KPIs m√©dios espec√≠ficos
            data_row['investimento'] = novo_investimento_val
            for kpi_col in kpi_cols:
                if kpi_col in data_row and kpi_col in kpis_atuais:
                    data_row[kpi_col] = kpis_atuais[kpi_col]
                elif kpi_col in data_row:
                    # Fallback para m√©dia geral se n√£o houver KPI espec√≠fico (improv√°vel se dados completos)
                    # Isso exigiria acesso ao X_train_imputed original ou suas m√©dias globais
                    # Para simplificar, vamos usar 0 ou uma m√©dia global pr√©-calculada se kpi_col n√£o estiver em kpis_atuais
                    # Em um cen√°rio real, voc√™ teria um fallback mais robusto.
                    pass # Deixa como 0 ou usa a m√©dia global se a coluna n√£o for preenchida

            # Gerar dummies para a linha de previs√£o
            # Criar um df tempor√°rio para gerar as dummies corretamente para essa linha
            temp_df_for_dummies = pd.DataFrame({
                'sexo': [sexo_original],
                'tipo_de_campanha': [tipo_original]
            })
            # Adicionar outras colunas categ√≥ricas se houver (dispositivo, idade, C√≥digo da moeda)
            # e preencher com a categoria mais frequente ou uma base para elas
            for cat_col in ['dispositivo', 'idade', 'C√≥digo da moeda']:
                if cat_col in df_for_dummies.columns:
                    temp_df_for_dummies[cat_col] = df_for_dummies[cat_col].mode()[0] # Usar a moda como padr√£o

            # Gerar as dummies para esta linha
            temp_dummies = pd.get_dummies(temp_df_for_dummies, columns=['sexo', 'tipo_de_campanha', 'dispositivo', 'idade', 'C√≥digo da moeda'], drop_first=True)

            # Preencher a data_row com as dummies geradas
            for dummy_col in temp_dummies.columns:
                if dummy_col in data_row:
                    data_row[dummy_col] = temp_dummies[dummy_col].iloc[0]

            # Criar DataFrame para previs√£o (com uma √∫nica linha)
            df_previsao = pd.DataFrame([data_row])

            # Garantir que as colunas e a ordem s√£o id√™nticas √†s de X_train_cols
            df_previsao = df_previsao[X_train_cols]

            # Aplicar escalonamento se o scaler foi fornecido
            if scaler_obj:
                df_previsao_final = pd.DataFrame(scaler_obj.transform(df_previsao), columns=df_previsao.columns)
            else:
                df_previsao_final = df_previsao

            # Fazer a previs√£o
            previsao_bruta = model.predict(df_previsao_final)[0]

            # Reverter logaritmo se a flag estiver ativada
            if log_transform_y_flag:
                previsao_final = np.expm1(previsao_bruta)
            else:
                previsao_final = previsao_bruta

            # Arredondar e garantir que a previs√£o n√£o seja negativa
            leads_previstos = max(0, round(previsao_final, 0))

            resultados.append({
                'Tipo de Campanha': tipo_original,
                'Sexo': sexo_original,
                'Investimento (R$)': novo_investimento_val,
                'Leads Previstos': leads_previstos
            })

    return pd.DataFrame(resultados)


# --- Carregar Modelo e Dados (uma vez por sess√£o Streamlit) ---
modelo = load_model()
df_original, df_processed_for_dummies, X_train_imputed_columns, kpis_medios_por_campanha, sexo_categorias, tipo_campanha_categorias, scaler, log_transform_y = load_and_preprocess_data()


# --- Interface do Usu√°rio no Streamlit ---
st.sidebar.header("Configura√ß√µes de Simula√ß√£o")
novo_investimento_input = st.sidebar.number_input(
    "Insira o valor do Investimento (R$):",
    min_value=0.0,
    value=200000.0, # Valor padr√£o
    step=1000.0,
    format="%.2f"
)

if st.sidebar.button("Gerar Previs√µes"):
    if novo_investimento_input is not None:
        st.subheader(f"Resultados da Simula√ß√£o para Investimento de R$ {novo_investimento_input:,.2f}")

        # Gerar os resultados da simula√ß√£o
        df_simulacao_completa = predict_leads_for_investment(
            novo_investimento_input,
            modelo,
            X_train_imputed_columns,
            kpis_medios_por_campanha,
            sexo_categorias,
            tipo_campanha_categorias,
            df_original, # Passa o df_original para ajudar na cria√ß√£o das dummies
            scaler_obj=scaler, # Passa o scaler se usado
            log_transform_y_flag=log_transform_y # Passa a flag de log transform
        )

        # --- Exibir Tabela Completa ---
        st.write("### Tabela Completa de Leads Previstos por Sexo e Tipo de Campanha")
        st.dataframe(df_simulacao_completa)

        # --- Gr√°fico de Leads Previstos por Tipo de Campanha e Sexo ---
        st.write("### Gr√°fico: Leads Previstos por Tipo de Campanha e Sexo")
        fig1, ax1 = plt.subplots(figsize=(12, 7))
        sns.barplot(data=df_simulacao_completa, x='Tipo de Campanha', y='Leads Previstos', hue='Sexo', palette='viridis', ax=ax1)
        ax1.set_title(f"Leads Previstos por Tipo de Campanha e Sexo (Investimento: R$ {novo_investimento_input:,.2f})")
        ax1.set_xlabel("Tipo de Campanha")
        ax1.set_ylabel("Total de Leads Previstos")
        plt.xticks(rotation=45, ha='right')
        st.pyplot(fig1)

        # --- Tabela de Leads Previstos Agrupados por Tipo de Campanha ---
        st.write("### Tabela: Total de Leads Previstos por Tipo de Campanha")
        df_total_por_campanha = df_simulacao_completa.groupby('Tipo de Campanha')['Leads Previstos'].sum().reset_index()
        st.dataframe(df_total_por_campanha)

        # --- Gr√°fico de Leads Previstos Agrupados por Tipo de Campanha ---
        st.write("### Gr√°fico: Total de Leads Previstos por Tipo de Campanha")
        fig2, ax2 = plt.subplots(figsize=(10, 6))
        sns.barplot(data=df_total_por_campanha, x='Tipo de Campanha', y='Leads Previstos', palette='coolwarm', ax=ax2)
        ax2.set_title(f"Total de Leads Previstos por Tipo de Campanha (Investimento: R$ {novo_investimento_input:,.2f})")
        ax2.set_xlabel("Tipo de Campanha")
        ax2.set_ylabel("Total de Leads Previstos")
        plt.xticks(rotation=45, ha='right')
        st.pyplot(fig2)

        # --- Tabela de Leads Previstos Agrupados por Sexo ---
        st.write("### Tabela: Total de Leads Previstos por Sexo")
        df_total_por_sexo = df_simulacao_completa.groupby('Sexo')['Leads Previstos'].sum().reset_index()
        st.dataframe(df_total_por_sexo)

        # --- Gr√°fico de Leads Previstos Agrupados por Sexo ---
        st.write("### Gr√°fico: Total de Leads Previstos por Sexo")
        fig3, ax3 = plt.subplots(figsize=(8, 5))
        sns.barplot(data=df_total_por_sexo, x='Sexo', y='Leads Previstos', palette='plasma', ax=ax3)
        ax3.set_title(f"Total de Leads Previstos por Sexo (Investimento: R$ {novo_investimento_input:,.2f})")
        ax3.set_xlabel("Sexo")
        ax3.set_ylabel("Total de Leads Previstos")
        st.pyplot(fig3)

import joblib
import pandas as pd
import numpy as np

# --- No seu script de treinamento, ap√≥s todas as etapas de pr√©-processamento e treinamento ---

# 1. Salvar o modelo treinado (modelo_lr)
joblib.dump(modelo_lr, 'modelo_lr.pkl')

# 2. Salvar o DataFrame original limpo (df)
# Este 'df' deve ser o DataFrame ap√≥s a limpeza inicial de NaNs em 'leads'
# e a convers√£o de tipos (antes do pd.get_dummies e train_test_split).
# Ele √© usado para obter as categorias e calcular KPIs m√©dios.
joblib.dump(df, 'df_original_limpo.pkl')

# 3. Salvar as colunas de X_train_imputed (para garantir a ordem das features)
joblib.dump(X_train_imputed.columns.tolist(), 'X_columns.pkl')

# 4. Salvar o scaler (se voc√™ usou StandardScaler ou outro escalonador)
# Descomente a linha abaixo se voc√™ usou um scaler no seu pipeline de treinamento.
# joblib.dump(scaler, 'scaler.pkl')

# 5. Salvar a flag de transforma√ß√£o logar√≠tmica em y (se voc√™ usou np.log1p em 'leads')
# Descomente e ajuste a linha abaixo se voc√™ aplicou np.log1p em y_train.
# with open('log_transform_y_flag.txt', 'w') as f:
#     f.write(str(log_transform_y)) # log_transform_y seria True ou False
